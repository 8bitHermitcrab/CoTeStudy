# -*- coding: utf-8 -*-
"""체스판다시칠하기.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WB5wwFwD71Shi5Kd876NxNnStqgAyQmi
"""

N,M=map(int,input().split())
wboard=[0,1]*4
cnt=[]
for _ in range(N):
  horizontal=[0]*M
  a=input()
  for i in range(len(a)):
    if a[i]=='B':
      horizontal[i]=1      
  for i in range(M-7):
    # 가로를 8개씩 잘라서 wboard와의 차이 계산
    # ex: WBWBWBWBWWW->WBWBWBWB, BWBWBWBW, WBWBWBWW,BWBWBWWW
    sum_white=0
    for j in range(8):
      # wboard와의 차이 sum 계산: WB와 BW를 구분하기 위해 절댓값으로 계산(BWBWBWBW는 차이가 6으로 나옴)
      # WBWBWBWB 01010101
      # BWBWBWBW 10101010
      # -----------------
      #          -1,1,-1,1,-1,1
      #          1,1,1,1,1,1  6
      sum_white+=abs(horizontal[i:i+8][j]-wboard[j])
    cnt.append(sum_white)
# cnt: (a,b)에서 시작하는 WBWBWBWB 8줄을 만들기 위해 칠해야 할 갯수(0<a<=M-8,0<b<=N-8)
# (a,b) 순서: a=0,b=0으로 시작해서 b부터 늘어나고 a가 늘어남
print(cnt)

WBWBWBWBWBWBBBB
BWBWBWBWBWBWWWW
WBWBWBWBWBWBBBB
BWBWBWBWBWBWWWW
WBWBWBWBWBWBBBB
WBWBWBWBWBWBBBB
WBWBWBWBWBWBBBB
BWBWBWBWBWBWWWW
BBBBBBBBBBBBBBB

# 최악의 경우의 수인 32를 best의 기본값으로 설정
best=32 
for i in range(M-7):  # a
  for j in range(N-7):  # b
    print(cnt[i::M-7][j:j+8]) # (a,b)에서 시작하는 8*8에서 wboard에 맞추기 위해 칠해야 하는 갯수
    # 짝수행일때와 홀수행일때를 나눔:
    #  짝수행일 경우 WBWBWBWB과 일치하지 않는 갯수를 세고, 홀수행일 경우 8*8/2에서 WBWBWBWB와 일치하지 않는 갯수를 뺌:
    #   홀수행은 BWBWBWBW와 일치하지 않는 갯수임(한 행에서 WB와 일치하지 않는 갯수와 BW와 일치하지 않는 갯수를 더하면 8이므로 BW 갯수는 8-WB이고, 그런 행이 4행 있으므로 4를 곱함)
    white=sum(cnt[i::M-7][j:j+8][::2])+(32-sum(cnt[i::M-7][j:j+8][1::2]))
    # WB로 시작할 경우 칠해야할 갯수
    print('white:',white)
    # BW로 시작할 경우 칠해야할 갯수
    print('black:',64-white)
    # 최솟값을 저장
    if min(white,64-white)<best:
      best=min(white,64-white)
    print('--------next---------')
print(best)

# 체스판 다시 칠하기 참고:https://bambbang00.tistory.com/43

n, m = map(int, input().split())

# 칠해야될 보드판
board = []
cnt = []

for _ in range(n):
    board.append(input())
print(board)

# 8부터 시작하는 인덱스
for row in range(n-7):
    for col in range(m-7):
        # W로 시작할 경우의 바뀐 개수
        indexW = 0
        # B로 시작할 경우
        indexB = 0 

        # 0~7 = 8칸
        for i in range(row, row+8):
            for j in range(col, col+8):
                # 합이 짝수면 시작점과 같은 색깔
                if (i+j) % 2 == 0:
                    if board[i][j] != 'W':
                        indexW += 1
                    if board[i][j] != 'B':
                        indexB += 1
                # 합이 홀수면 시작점과 다른 색깔이어야함
                else:
                    if board[i][j] != 'B':
                        indexW += 1
                    if board[i][j] != 'W':
                        indexB += 1
                    print(indexW,indexB)
        cnt.append(indexW)
        cnt.append(indexB)

print(min(cnt))